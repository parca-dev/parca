// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file parca/metastore/v1alpha1/metastore.proto (package parca.metastore.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64 } from "@bufbuild/protobuf";

/**
 * GetOrCreateMappingsRequest contains all information about mappings that are
 * requested to be retrieved or created if they don't already exist.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateMappingsRequest
 */
export class GetOrCreateMappingsRequest extends Message<GetOrCreateMappingsRequest> {
  /**
   * Mappings to be created or retrieved.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Mapping mappings = 1;
   */
  mappings: Mapping[] = [];

  constructor(data?: PartialMessage<GetOrCreateMappingsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateMappingsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mappings", kind: "message", T: Mapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateMappingsRequest {
    return new GetOrCreateMappingsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateMappingsRequest {
    return new GetOrCreateMappingsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateMappingsRequest {
    return new GetOrCreateMappingsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateMappingsRequest | PlainMessage<GetOrCreateMappingsRequest> | undefined, b: GetOrCreateMappingsRequest | PlainMessage<GetOrCreateMappingsRequest> | undefined): boolean {
    return proto3.util.equals(GetOrCreateMappingsRequest, a, b);
  }
}

/**
 * GetOrCreateMappingsResponse contains information about mappings requested.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateMappingsResponse
 */
export class GetOrCreateMappingsResponse extends Message<GetOrCreateMappingsResponse> {
  /**
   * Mappings that are known to the backing metastore. If any mappings didn't
   * exist before the request they have now been persisted and are uniquely
   * identifyable through their key.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Mapping mappings = 1;
   */
  mappings: Mapping[] = [];

  constructor(data?: PartialMessage<GetOrCreateMappingsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateMappingsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mappings", kind: "message", T: Mapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateMappingsResponse {
    return new GetOrCreateMappingsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateMappingsResponse {
    return new GetOrCreateMappingsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateMappingsResponse {
    return new GetOrCreateMappingsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateMappingsResponse | PlainMessage<GetOrCreateMappingsResponse> | undefined, b: GetOrCreateMappingsResponse | PlainMessage<GetOrCreateMappingsResponse> | undefined): boolean {
    return proto3.util.equals(GetOrCreateMappingsResponse, a, b);
  }
}

/**
 * GetOrCreateFunctionsRequest contains all information about functions that are
 * requested to be retrieved or created if they don't already exist.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateFunctionsRequest
 */
export class GetOrCreateFunctionsRequest extends Message<GetOrCreateFunctionsRequest> {
  /**
   * Functions to be created or retrieved.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Function functions = 1;
   */
  functions: Function[] = [];

  constructor(data?: PartialMessage<GetOrCreateFunctionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateFunctionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "functions", kind: "message", T: Function, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateFunctionsRequest {
    return new GetOrCreateFunctionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateFunctionsRequest {
    return new GetOrCreateFunctionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateFunctionsRequest {
    return new GetOrCreateFunctionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateFunctionsRequest | PlainMessage<GetOrCreateFunctionsRequest> | undefined, b: GetOrCreateFunctionsRequest | PlainMessage<GetOrCreateFunctionsRequest> | undefined): boolean {
    return proto3.util.equals(GetOrCreateFunctionsRequest, a, b);
  }
}

/**
 * GetOrCreateFunctionsResponse contains information about functions requested.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateFunctionsResponse
 */
export class GetOrCreateFunctionsResponse extends Message<GetOrCreateFunctionsResponse> {
  /**
   * Functions that are known to the backing metastore. If any functions didn't
   * exist before the request they have now been persisted and are uniquely
   * identifyable through their key.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Function functions = 1;
   */
  functions: Function[] = [];

  constructor(data?: PartialMessage<GetOrCreateFunctionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateFunctionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "functions", kind: "message", T: Function, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateFunctionsResponse {
    return new GetOrCreateFunctionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateFunctionsResponse {
    return new GetOrCreateFunctionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateFunctionsResponse {
    return new GetOrCreateFunctionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateFunctionsResponse | PlainMessage<GetOrCreateFunctionsResponse> | undefined, b: GetOrCreateFunctionsResponse | PlainMessage<GetOrCreateFunctionsResponse> | undefined): boolean {
    return proto3.util.equals(GetOrCreateFunctionsResponse, a, b);
  }
}

/**
 * GetOrCreateLocationsRequest contains all information about locations that are
 * requested to be retrieved or created if they don't already exist.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateLocationsRequest
 */
export class GetOrCreateLocationsRequest extends Message<GetOrCreateLocationsRequest> {
  /**
   * Locations to be created or retrieved.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Location locations = 1;
   */
  locations: Location[] = [];

  constructor(data?: PartialMessage<GetOrCreateLocationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateLocationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locations", kind: "message", T: Location, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateLocationsRequest {
    return new GetOrCreateLocationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateLocationsRequest {
    return new GetOrCreateLocationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateLocationsRequest {
    return new GetOrCreateLocationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateLocationsRequest | PlainMessage<GetOrCreateLocationsRequest> | undefined, b: GetOrCreateLocationsRequest | PlainMessage<GetOrCreateLocationsRequest> | undefined): boolean {
    return proto3.util.equals(GetOrCreateLocationsRequest, a, b);
  }
}

/**
 * GetOrCreateLocationsResponse contains information about locations requested.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateLocationsResponse
 */
export class GetOrCreateLocationsResponse extends Message<GetOrCreateLocationsResponse> {
  /**
   * Locations that are known to the backing metastore. If any locations didn't
   * exist before the request they have now been persisted and are uniquely
   * identifyable through their key.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Location locations = 1;
   */
  locations: Location[] = [];

  constructor(data?: PartialMessage<GetOrCreateLocationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateLocationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locations", kind: "message", T: Location, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateLocationsResponse {
    return new GetOrCreateLocationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateLocationsResponse {
    return new GetOrCreateLocationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateLocationsResponse {
    return new GetOrCreateLocationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateLocationsResponse | PlainMessage<GetOrCreateLocationsResponse> | undefined, b: GetOrCreateLocationsResponse | PlainMessage<GetOrCreateLocationsResponse> | undefined): boolean {
    return proto3.util.equals(GetOrCreateLocationsResponse, a, b);
  }
}

/**
 * GetOrCreateStracktracesRequest contains all information about stacktraces
 * that are requested to be retrieved or created if they don't already exist.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateStacktracesRequest
 */
export class GetOrCreateStacktracesRequest extends Message<GetOrCreateStacktracesRequest> {
  /**
   * Stacktraces to be created or retrieved.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Stacktrace stacktraces = 1;
   */
  stacktraces: Stacktrace[] = [];

  constructor(data?: PartialMessage<GetOrCreateStacktracesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateStacktracesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stacktraces", kind: "message", T: Stacktrace, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateStacktracesRequest {
    return new GetOrCreateStacktracesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateStacktracesRequest {
    return new GetOrCreateStacktracesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateStacktracesRequest {
    return new GetOrCreateStacktracesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateStacktracesRequest | PlainMessage<GetOrCreateStacktracesRequest> | undefined, b: GetOrCreateStacktracesRequest | PlainMessage<GetOrCreateStacktracesRequest> | undefined): boolean {
    return proto3.util.equals(GetOrCreateStacktracesRequest, a, b);
  }
}

/**
 * GetOrCreateStacktracesResponse contains information about locations requested.
 *
 * @generated from message parca.metastore.v1alpha1.GetOrCreateStacktracesResponse
 */
export class GetOrCreateStacktracesResponse extends Message<GetOrCreateStacktracesResponse> {
  /**
   * Stacktraces that are known to the backing metastore. If any stacktraces
   * didn't exist before the request they have now been persisted and are
   * uniquely identifyable through their key.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Stacktrace stacktraces = 1;
   */
  stacktraces: Stacktrace[] = [];

  constructor(data?: PartialMessage<GetOrCreateStacktracesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.GetOrCreateStacktracesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stacktraces", kind: "message", T: Stacktrace, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetOrCreateStacktracesResponse {
    return new GetOrCreateStacktracesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetOrCreateStacktracesResponse {
    return new GetOrCreateStacktracesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetOrCreateStacktracesResponse {
    return new GetOrCreateStacktracesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetOrCreateStacktracesResponse | PlainMessage<GetOrCreateStacktracesResponse> | undefined, b: GetOrCreateStacktracesResponse | PlainMessage<GetOrCreateStacktracesResponse> | undefined): boolean {
    return proto3.util.equals(GetOrCreateStacktracesResponse, a, b);
  }
}

/**
 * UnsymbolizedLocationsRequest contains information about the unsymbolized
 * locations requested. While currently empty, this could in the future contain
 * a sharding configuration or limit the number of locations to return.
 *
 * @generated from message parca.metastore.v1alpha1.UnsymbolizedLocationsRequest
 */
export class UnsymbolizedLocationsRequest extends Message<UnsymbolizedLocationsRequest> {
  /**
   * The maximum number of locations to return.
   *
   * @generated from field: uint32 limit = 1;
   */
  limit = 0;

  /**
   * The minimum key to start returning locations from.
   *
   * @generated from field: string min_key = 2;
   */
  minKey = "";

  constructor(data?: PartialMessage<UnsymbolizedLocationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.UnsymbolizedLocationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "min_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnsymbolizedLocationsRequest {
    return new UnsymbolizedLocationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnsymbolizedLocationsRequest {
    return new UnsymbolizedLocationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnsymbolizedLocationsRequest {
    return new UnsymbolizedLocationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnsymbolizedLocationsRequest | PlainMessage<UnsymbolizedLocationsRequest> | undefined, b: UnsymbolizedLocationsRequest | PlainMessage<UnsymbolizedLocationsRequest> | undefined): boolean {
    return proto3.util.equals(UnsymbolizedLocationsRequest, a, b);
  }
}

/**
 * UnsymbolizedLocationsResponse contains information about the requested
 * locations that should be symbolizable but potentially haven't been
 * symbolized yet.
 *
 * @generated from message parca.metastore.v1alpha1.UnsymbolizedLocationsResponse
 */
export class UnsymbolizedLocationsResponse extends Message<UnsymbolizedLocationsResponse> {
  /**
   * Locations that have a mapping and address that should be symbolizable.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Location locations = 1;
   */
  locations: Location[] = [];

  /**
   * Key of the last location returned. This can be used in a subsequent call
   * to UnsymbolizedLocations to continue from the last returned location.
   *
   * @generated from field: string max_key = 2;
   */
  maxKey = "";

  constructor(data?: PartialMessage<UnsymbolizedLocationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.UnsymbolizedLocationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locations", kind: "message", T: Location, repeated: true },
    { no: 2, name: "max_key", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnsymbolizedLocationsResponse {
    return new UnsymbolizedLocationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnsymbolizedLocationsResponse {
    return new UnsymbolizedLocationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnsymbolizedLocationsResponse {
    return new UnsymbolizedLocationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnsymbolizedLocationsResponse | PlainMessage<UnsymbolizedLocationsResponse> | undefined, b: UnsymbolizedLocationsResponse | PlainMessage<UnsymbolizedLocationsResponse> | undefined): boolean {
    return proto3.util.equals(UnsymbolizedLocationsResponse, a, b);
  }
}

/**
 * CreateLocationLinesRequest contains locations and their location lines to be
 * saved.
 *
 * @generated from message parca.metastore.v1alpha1.CreateLocationLinesRequest
 */
export class CreateLocationLinesRequest extends Message<CreateLocationLinesRequest> {
  /**
   * Locations that have location lines to be saved.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Location locations = 1;
   */
  locations: Location[] = [];

  constructor(data?: PartialMessage<CreateLocationLinesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.CreateLocationLinesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locations", kind: "message", T: Location, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateLocationLinesRequest {
    return new CreateLocationLinesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateLocationLinesRequest {
    return new CreateLocationLinesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateLocationLinesRequest {
    return new CreateLocationLinesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: CreateLocationLinesRequest | PlainMessage<CreateLocationLinesRequest> | undefined, b: CreateLocationLinesRequest | PlainMessage<CreateLocationLinesRequest> | undefined): boolean {
    return proto3.util.equals(CreateLocationLinesRequest, a, b);
  }
}

/**
 * CreateLocationLinesResponse details about the location lines creation.
 *
 * @generated from message parca.metastore.v1alpha1.CreateLocationLinesResponse
 */
export class CreateLocationLinesResponse extends Message<CreateLocationLinesResponse> {
  constructor(data?: PartialMessage<CreateLocationLinesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.CreateLocationLinesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CreateLocationLinesResponse {
    return new CreateLocationLinesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CreateLocationLinesResponse {
    return new CreateLocationLinesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CreateLocationLinesResponse {
    return new CreateLocationLinesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: CreateLocationLinesResponse | PlainMessage<CreateLocationLinesResponse> | undefined, b: CreateLocationLinesResponse | PlainMessage<CreateLocationLinesResponse> | undefined): boolean {
    return proto3.util.equals(CreateLocationLinesResponse, a, b);
  }
}

/**
 * StacktracesRequest contains information about the stacktraces requested.
 *
 * @generated from message parca.metastore.v1alpha1.StacktracesRequest
 */
export class StacktracesRequest extends Message<StacktracesRequest> {
  /**
   * IDs of stacktraces to retrieve.
   *
   * @generated from field: repeated string stacktrace_ids = 1;
   */
  stacktraceIds: string[] = [];

  constructor(data?: PartialMessage<StacktracesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.StacktracesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stacktrace_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StacktracesRequest {
    return new StacktracesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StacktracesRequest {
    return new StacktracesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StacktracesRequest {
    return new StacktracesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: StacktracesRequest | PlainMessage<StacktracesRequest> | undefined, b: StacktracesRequest | PlainMessage<StacktracesRequest> | undefined): boolean {
    return proto3.util.equals(StacktracesRequest, a, b);
  }
}

/**
 * StacktracesRequest contains the requested stacktraces.
 *
 * @generated from message parca.metastore.v1alpha1.StacktracesResponse
 */
export class StacktracesResponse extends Message<StacktracesResponse> {
  /**
   * Stacktraces that are known to the backing metastore.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Stacktrace stacktraces = 1;
   */
  stacktraces: Stacktrace[] = [];

  constructor(data?: PartialMessage<StacktracesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.StacktracesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stacktraces", kind: "message", T: Stacktrace, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StacktracesResponse {
    return new StacktracesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StacktracesResponse {
    return new StacktracesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StacktracesResponse {
    return new StacktracesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: StacktracesResponse | PlainMessage<StacktracesResponse> | undefined, b: StacktracesResponse | PlainMessage<StacktracesResponse> | undefined): boolean {
    return proto3.util.equals(StacktracesResponse, a, b);
  }
}

/**
 * LocationsRequest contains information about the locations requested.
 *
 * @generated from message parca.metastore.v1alpha1.LocationsRequest
 */
export class LocationsRequest extends Message<LocationsRequest> {
  /**
   * IDs of locations to retrieve.
   *
   * @generated from field: repeated string location_ids = 1;
   */
  locationIds: string[] = [];

  constructor(data?: PartialMessage<LocationsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.LocationsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationsRequest {
    return new LocationsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationsRequest {
    return new LocationsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationsRequest {
    return new LocationsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LocationsRequest | PlainMessage<LocationsRequest> | undefined, b: LocationsRequest | PlainMessage<LocationsRequest> | undefined): boolean {
    return proto3.util.equals(LocationsRequest, a, b);
  }
}

/**
 * LocationsResponse contains the requested locations.
 *
 * @generated from message parca.metastore.v1alpha1.LocationsResponse
 */
export class LocationsResponse extends Message<LocationsResponse> {
  /**
   * Locations that are known to the backing metastore.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Location locations = 1;
   */
  locations: Location[] = [];

  constructor(data?: PartialMessage<LocationsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.LocationsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "locations", kind: "message", T: Location, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationsResponse {
    return new LocationsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationsResponse {
    return new LocationsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationsResponse {
    return new LocationsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LocationsResponse | PlainMessage<LocationsResponse> | undefined, b: LocationsResponse | PlainMessage<LocationsResponse> | undefined): boolean {
    return proto3.util.equals(LocationsResponse, a, b);
  }
}

/**
 * LocationLinesRequest contains information about the location's lines requested.
 *
 * @generated from message parca.metastore.v1alpha1.LocationLinesRequest
 */
export class LocationLinesRequest extends Message<LocationLinesRequest> {
  /**
   * IDs of locations to retrieve location lines for.
   *
   * @generated from field: repeated string location_ids = 1;
   */
  locationIds: string[] = [];

  constructor(data?: PartialMessage<LocationLinesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.LocationLinesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LocationLinesRequest {
    return new LocationLinesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LocationLinesRequest {
    return new LocationLinesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LocationLinesRequest {
    return new LocationLinesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LocationLinesRequest | PlainMessage<LocationLinesRequest> | undefined, b: LocationLinesRequest | PlainMessage<LocationLinesRequest> | undefined): boolean {
    return proto3.util.equals(LocationLinesRequest, a, b);
  }
}

/**
 * FunctionsRequest contains information about the functions requested.
 *
 * @generated from message parca.metastore.v1alpha1.FunctionsRequest
 */
export class FunctionsRequest extends Message<FunctionsRequest> {
  /**
   * IDs of functions to retrieve.
   *
   * @generated from field: repeated string function_ids = 1;
   */
  functionIds: string[] = [];

  constructor(data?: PartialMessage<FunctionsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.FunctionsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "function_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FunctionsRequest {
    return new FunctionsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FunctionsRequest {
    return new FunctionsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FunctionsRequest {
    return new FunctionsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: FunctionsRequest | PlainMessage<FunctionsRequest> | undefined, b: FunctionsRequest | PlainMessage<FunctionsRequest> | undefined): boolean {
    return proto3.util.equals(FunctionsRequest, a, b);
  }
}

/**
 * FunctionsResponse contains the requested functions.
 *
 * @generated from message parca.metastore.v1alpha1.FunctionsResponse
 */
export class FunctionsResponse extends Message<FunctionsResponse> {
  /**
   * Functions that are known to the backing metastore.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Function functions = 1;
   */
  functions: Function[] = [];

  constructor(data?: PartialMessage<FunctionsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.FunctionsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "functions", kind: "message", T: Function, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FunctionsResponse {
    return new FunctionsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FunctionsResponse {
    return new FunctionsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FunctionsResponse {
    return new FunctionsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: FunctionsResponse | PlainMessage<FunctionsResponse> | undefined, b: FunctionsResponse | PlainMessage<FunctionsResponse> | undefined): boolean {
    return proto3.util.equals(FunctionsResponse, a, b);
  }
}

/**
 * MappingsRequest contains information about the mappings requested.
 *
 * @generated from message parca.metastore.v1alpha1.MappingsRequest
 */
export class MappingsRequest extends Message<MappingsRequest> {
  /**
   * IDs of mappings to retrieve.
   *
   * @generated from field: repeated string mapping_ids = 1;
   */
  mappingIds: string[] = [];

  constructor(data?: PartialMessage<MappingsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.MappingsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mapping_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MappingsRequest {
    return new MappingsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MappingsRequest {
    return new MappingsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MappingsRequest {
    return new MappingsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: MappingsRequest | PlainMessage<MappingsRequest> | undefined, b: MappingsRequest | PlainMessage<MappingsRequest> | undefined): boolean {
    return proto3.util.equals(MappingsRequest, a, b);
  }
}

/**
 * MappingsResponse contains the requested mappings.
 *
 * @generated from message parca.metastore.v1alpha1.MappingsResponse
 */
export class MappingsResponse extends Message<MappingsResponse> {
  /**
   * Mappings that are known to the backing metastore.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Mapping mappings = 1;
   */
  mappings: Mapping[] = [];

  constructor(data?: PartialMessage<MappingsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.MappingsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mappings", kind: "message", T: Mapping, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MappingsResponse {
    return new MappingsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MappingsResponse {
    return new MappingsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MappingsResponse {
    return new MappingsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: MappingsResponse | PlainMessage<MappingsResponse> | undefined, b: MappingsResponse | PlainMessage<MappingsResponse> | undefined): boolean {
    return proto3.util.equals(MappingsResponse, a, b);
  }
}

/**
 * Sample is a stack trace with optional labels.
 *
 * @generated from message parca.metastore.v1alpha1.Sample
 */
export class Sample extends Message<Sample> {
  /**
   * stacktrace_id references stack trace of the sample.
   *
   * @generated from field: string stacktrace_id = 1;
   */
  stacktraceId = "";

  /**
   * labels are extra labels for a stack trace.
   *
   * @generated from field: map<string, parca.metastore.v1alpha1.SampleLabel> labels = 2;
   */
  labels: { [key: string]: SampleLabel } = {};

  /**
   * num_labels are the num of labels.
   *
   * @generated from field: map<string, parca.metastore.v1alpha1.SampleNumLabel> num_labels = 3;
   */
  numLabels: { [key: string]: SampleNumLabel } = {};

  /**
   * num_units are the units for the labels.
   *
   * @generated from field: map<string, parca.metastore.v1alpha1.SampleNumUnit> num_units = 4;
   */
  numUnits: { [key: string]: SampleNumUnit } = {};

  constructor(data?: PartialMessage<Sample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.Sample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "stacktrace_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SampleLabel} },
    { no: 3, name: "num_labels", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SampleNumLabel} },
    { no: 4, name: "num_units", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: SampleNumUnit} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Sample {
    return new Sample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Sample {
    return new Sample().fromJsonString(jsonString, options);
  }

  static equals(a: Sample | PlainMessage<Sample> | undefined, b: Sample | PlainMessage<Sample> | undefined): boolean {
    return proto3.util.equals(Sample, a, b);
  }
}

/**
 * Stacktrace is a collection of locations.
 *
 * @generated from message parca.metastore.v1alpha1.Stacktrace
 */
export class Stacktrace extends Message<Stacktrace> {
  /**
   * stacktrace_id references stack trace of the stacktrace.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * locations are the locations in the stack trace.
   *
   * @generated from field: repeated string location_ids = 2;
   */
  locationIds: string[] = [];

  constructor(data?: PartialMessage<Stacktrace>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.Stacktrace";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "location_ids", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Stacktrace {
    return new Stacktrace().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Stacktrace {
    return new Stacktrace().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Stacktrace {
    return new Stacktrace().fromJsonString(jsonString, options);
  }

  static equals(a: Stacktrace | PlainMessage<Stacktrace> | undefined, b: Stacktrace | PlainMessage<Stacktrace> | undefined): boolean {
    return proto3.util.equals(Stacktrace, a, b);
  }
}

/**
 * SampleLabel are the labels added to a Sample.
 *
 * @generated from message parca.metastore.v1alpha1.SampleLabel
 */
export class SampleLabel extends Message<SampleLabel> {
  /**
   * labels for a label in a Sample.
   *
   * @generated from field: repeated string labels = 1;
   */
  labels: string[] = [];

  constructor(data?: PartialMessage<SampleLabel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.SampleLabel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labels", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleLabel {
    return new SampleLabel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleLabel {
    return new SampleLabel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleLabel {
    return new SampleLabel().fromJsonString(jsonString, options);
  }

  static equals(a: SampleLabel | PlainMessage<SampleLabel> | undefined, b: SampleLabel | PlainMessage<SampleLabel> | undefined): boolean {
    return proto3.util.equals(SampleLabel, a, b);
  }
}

/**
 * SampleNumLabel are the num of labels of a Sample.
 *
 * @generated from message parca.metastore.v1alpha1.SampleNumLabel
 */
export class SampleNumLabel extends Message<SampleNumLabel> {
  /**
   * num_labels are the num_label of a Sample.
   *
   * @generated from field: repeated int64 num_labels = 1;
   */
  numLabels: bigint[] = [];

  constructor(data?: PartialMessage<SampleNumLabel>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.SampleNumLabel";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "num_labels", kind: "scalar", T: 3 /* ScalarType.INT64 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleNumLabel {
    return new SampleNumLabel().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleNumLabel {
    return new SampleNumLabel().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleNumLabel {
    return new SampleNumLabel().fromJsonString(jsonString, options);
  }

  static equals(a: SampleNumLabel | PlainMessage<SampleNumLabel> | undefined, b: SampleNumLabel | PlainMessage<SampleNumLabel> | undefined): boolean {
    return proto3.util.equals(SampleNumLabel, a, b);
  }
}

/**
 * SampleNumUnit are the num units of a Sample.
 *
 * @generated from message parca.metastore.v1alpha1.SampleNumUnit
 */
export class SampleNumUnit extends Message<SampleNumUnit> {
  /**
   * units of a labels of a Sample.
   *
   * @generated from field: repeated string units = 1;
   */
  units: string[] = [];

  constructor(data?: PartialMessage<SampleNumUnit>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.SampleNumUnit";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "units", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SampleNumUnit {
    return new SampleNumUnit().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SampleNumUnit {
    return new SampleNumUnit().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SampleNumUnit {
    return new SampleNumUnit().fromJsonString(jsonString, options);
  }

  static equals(a: SampleNumUnit | PlainMessage<SampleNumUnit> | undefined, b: SampleNumUnit | PlainMessage<SampleNumUnit> | undefined): boolean {
    return proto3.util.equals(SampleNumUnit, a, b);
  }
}

/**
 * Location describes a single location of a stack traces.
 *
 * @generated from message parca.metastore.v1alpha1.Location
 */
export class Location extends Message<Location> {
  /**
   * id is the unique identifier for the location.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * address is the memory address of the location if present.
   *
   * @generated from field: uint64 address = 2;
   */
  address = protoInt64.zero;

  /**
   * mapping_id is the unique identifier for the mapping associated with the location.
   *
   * @generated from field: string mapping_id = 4;
   */
  mappingId = "";

  /**
   * is_folded indicates whether the location is folded into the previous location.
   *
   * @generated from field: bool is_folded = 5;
   */
  isFolded = false;

  /**
   * lines are the call frames represented by this location. Multiple lines
   * indicate they have been inlined.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Line lines = 6;
   */
  lines: Line[] = [];

  /**
   * mapping_index has the index into the mapping table where mappings are sent deduplicated.
   *
   * @generated from field: uint32 mapping_index = 7;
   */
  mappingIndex = 0;

  constructor(data?: PartialMessage<Location>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.Location";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "address", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "mapping_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "is_folded", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 6, name: "lines", kind: "message", T: Line, repeated: true },
    { no: 7, name: "mapping_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Location {
    return new Location().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Location {
    return new Location().fromJsonString(jsonString, options);
  }

  static equals(a: Location | PlainMessage<Location> | undefined, b: Location | PlainMessage<Location> | undefined): boolean {
    return proto3.util.equals(Location, a, b);
  }
}

/**
 * Line describes a source code function and its line number.
 *
 * @generated from message parca.metastore.v1alpha1.Line
 */
export class Line extends Message<Line> {
  /**
   * function_id is the ID of the function.
   *
   * @generated from field: string function_id = 1;
   */
  functionId = "";

  /**
   * line is the line number in the source file of the referenced function.
   *
   * @generated from field: int64 line = 2;
   */
  line = protoInt64.zero;

  /**
   * function_index is the index in the functions table.
   *
   * @generated from field: uint32 function_index = 3;
   */
  functionIndex = 0;

  constructor(data?: PartialMessage<Line>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.Line";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "function_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "line", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "function_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Line {
    return new Line().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Line {
    return new Line().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Line {
    return new Line().fromJsonString(jsonString, options);
  }

  static equals(a: Line | PlainMessage<Line> | undefined, b: Line | PlainMessage<Line> | undefined): boolean {
    return proto3.util.equals(Line, a, b);
  }
}

/**
 * Function describes metadata of a source code function.
 *
 * @generated from message parca.metastore.v1alpha1.Function
 */
export class Function extends Message<Function> {
  /**
   * id is the unique identifier for the function.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * start_line is the line number in the source file of the first line of the function.
   *
   * @generated from field: int64 start_line = 2;
   */
  startLine = protoInt64.zero;

  /**
   * name is the name of the function.
   *
   * @generated from field: string name = 3;
   */
  name = "";

  /**
   * system_name describes the name of the function, as identified by the
   * system. For instance, it can be a C++ mangled name.
   *
   * @generated from field: string system_name = 4;
   */
  systemName = "";

  /**
   * filename is the name of the source file of the function.
   *
   * @generated from field: string filename = 5;
   */
  filename = "";

  /**
   * name_string_index is the index in the string table to the name associated with the function.
   *
   * @generated from field: uint32 name_string_index = 6;
   */
  nameStringIndex = 0;

  /**
   * system_name_string_index is the index in the string table to the system_name associated with the function.
   *
   * @generated from field: uint32 system_name_string_index = 7;
   */
  systemNameStringIndex = 0;

  /**
   * filename_string_index is the index in the string table to the filename associated with the function.
   *
   * @generated from field: uint32 filename_string_index = 8;
   */
  filenameStringIndex = 0;

  constructor(data?: PartialMessage<Function>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.Function";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start_line", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "system_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "filename", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "name_string_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 7, name: "system_name_string_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 8, name: "filename_string_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Function {
    return new Function().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Function {
    return new Function().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Function {
    return new Function().fromJsonString(jsonString, options);
  }

  static equals(a: Function | PlainMessage<Function> | undefined, b: Function | PlainMessage<Function> | undefined): boolean {
    return proto3.util.equals(Function, a, b);
  }
}

/**
 * Mapping describes a memory mapping.
 *
 * @generated from message parca.metastore.v1alpha1.Mapping
 */
export class Mapping extends Message<Mapping> {
  /**
   * id is the unique identifier for the mapping.
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * start is the start address of the mapping.
   *
   * @generated from field: uint64 start = 2;
   */
  start = protoInt64.zero;

  /**
   * limit is the length of the address space of the mapping.
   *
   * @generated from field: uint64 limit = 3;
   */
  limit = protoInt64.zero;

  /**
   * offset in the binary that corresponds to the first mapped address.
   *
   * @generated from field: uint64 offset = 4;
   */
  offset = protoInt64.zero;

  /**
   * file is the name of the file associated with the mapping.
   *
   * @generated from field: string file = 5;
   */
  file = "";

  /**
   * build_id is the build ID of the mapping.
   *
   * @generated from field: string build_id = 6;
   */
  buildId = "";

  /**
   * has_functions indicates whether the mapping has associated functions.
   *
   * @generated from field: bool has_functions = 7;
   */
  hasFunctions = false;

  /**
   * has_filenames indicates whether the mapping has associated filenames.
   *
   * @generated from field: bool has_filenames = 8;
   */
  hasFilenames = false;

  /**
   * has_line_numbers indicates whether the mapping has associated line numbers.
   *
   * @generated from field: bool has_line_numbers = 9;
   */
  hasLineNumbers = false;

  /**
   * has_inline_frames indicates whether the mapping has associated inline frames.
   *
   * @generated from field: bool has_inline_frames = 10;
   */
  hasInlineFrames = false;

  /**
   * fileStringIndex is the index in the string table to the file name associated with the mapping.
   *
   * @generated from field: uint32 file_string_index = 11;
   */
  fileStringIndex = 0;

  /**
   * build_id_string_index is the index in the string table to the build ID of the mapping.
   *
   * @generated from field: uint32 build_id_string_index = 12;
   */
  buildIdStringIndex = 0;

  constructor(data?: PartialMessage<Mapping>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.metastore.v1alpha1.Mapping";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 3, name: "limit", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 4, name: "offset", kind: "scalar", T: 4 /* ScalarType.UINT64 */ },
    { no: 5, name: "file", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "build_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "has_functions", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 8, name: "has_filenames", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 9, name: "has_line_numbers", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 10, name: "has_inline_frames", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 11, name: "file_string_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 12, name: "build_id_string_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Mapping {
    return new Mapping().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Mapping {
    return new Mapping().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Mapping {
    return new Mapping().fromJsonString(jsonString, options);
  }

  static equals(a: Mapping | PlainMessage<Mapping> | undefined, b: Mapping | PlainMessage<Mapping> | undefined): boolean {
    return proto3.util.equals(Mapping, a, b);
  }
}

