// @generated by protoc-gen-es v1.2.0 with parameter "target=ts"
// @generated from file parca/query/v1alpha1/query.proto (package parca.query.v1alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";
import { LabelSet } from "../../profilestore/v1alpha1/profilestore_pb.js";
import { Function, Line, Location, Mapping } from "../../metastore/v1alpha1/metastore_pb.js";

/**
 * ProfileTypesRequest is the request to retrieve the list of available profile types.
 *
 * @generated from message parca.query.v1alpha1.ProfileTypesRequest
 */
export class ProfileTypesRequest extends Message<ProfileTypesRequest> {
  constructor(data?: PartialMessage<ProfileTypesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ProfileTypesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProfileTypesRequest {
    return new ProfileTypesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProfileTypesRequest {
    return new ProfileTypesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProfileTypesRequest {
    return new ProfileTypesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ProfileTypesRequest | PlainMessage<ProfileTypesRequest> | undefined, b: ProfileTypesRequest | PlainMessage<ProfileTypesRequest> | undefined): boolean {
    return proto3.util.equals(ProfileTypesRequest, a, b);
  }
}

/**
 * ProfileTypesResponse is the response to retrieve the list of available profile types.
 *
 * @generated from message parca.query.v1alpha1.ProfileTypesResponse
 */
export class ProfileTypesResponse extends Message<ProfileTypesResponse> {
  /**
   * types is the list of available profile types.
   *
   * @generated from field: repeated parca.query.v1alpha1.ProfileType types = 1;
   */
  types: ProfileType[] = [];

  constructor(data?: PartialMessage<ProfileTypesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ProfileTypesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "types", kind: "message", T: ProfileType, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProfileTypesResponse {
    return new ProfileTypesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProfileTypesResponse {
    return new ProfileTypesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProfileTypesResponse {
    return new ProfileTypesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ProfileTypesResponse | PlainMessage<ProfileTypesResponse> | undefined, b: ProfileTypesResponse | PlainMessage<ProfileTypesResponse> | undefined): boolean {
    return proto3.util.equals(ProfileTypesResponse, a, b);
  }
}

/**
 * ProfileType is the type of a profile as well as the units the profile type is available in.
 *
 * @generated from message parca.query.v1alpha1.ProfileType
 */
export class ProfileType extends Message<ProfileType> {
  /**
   * name is the name of the profile type.
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * sample_type is the type of the samples in the profile.
   *
   * @generated from field: string sample_type = 2;
   */
  sampleType = "";

  /**
   * sample_unit is the unit of the samples in the profile.
   *
   * @generated from field: string sample_unit = 3;
   */
  sampleUnit = "";

  /**
   * period_type is the type of the periods in the profile.
   *
   * @generated from field: string period_type = 4;
   */
  periodType = "";

  /**
   * period_unit is the unit of the periods in the profile.
   *
   * @generated from field: string period_unit = 5;
   */
  periodUnit = "";

  /**
   * delta describes whether the profile is a delta profile.
   *
   * @generated from field: bool delta = 6;
   */
  delta = false;

  constructor(data?: PartialMessage<ProfileType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ProfileType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "sample_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "sample_unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "period_type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "period_unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "delta", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProfileType {
    return new ProfileType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProfileType {
    return new ProfileType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProfileType {
    return new ProfileType().fromJsonString(jsonString, options);
  }

  static equals(a: ProfileType | PlainMessage<ProfileType> | undefined, b: ProfileType | PlainMessage<ProfileType> | undefined): boolean {
    return proto3.util.equals(ProfileType, a, b);
  }
}

/**
 * QueryRangeRequest is the request for a set of profiles matching a query over a time window
 *
 * @generated from message parca.query.v1alpha1.QueryRangeRequest
 */
export class QueryRangeRequest extends Message<QueryRangeRequest> {
  /**
   * query is the query string to match profiles against
   *
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * start is the start of the query time window
   *
   * @generated from field: google.protobuf.Timestamp start = 2;
   */
  start?: Timestamp;

  /**
   * end is the end of the query time window
   *
   * @generated from field: google.protobuf.Timestamp end = 3;
   */
  end?: Timestamp;

  /**
   * limit is the max number of profiles to include in the response
   *
   * @generated from field: uint32 limit = 4;
   */
  limit = 0;

  /**
   * step is the duration of each sample returned.
   *
   * @generated from field: google.protobuf.Duration step = 5;
   */
  step?: Duration;

  constructor(data?: PartialMessage<QueryRangeRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.QueryRangeRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start", kind: "message", T: Timestamp },
    { no: 3, name: "end", kind: "message", T: Timestamp },
    { no: 4, name: "limit", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 5, name: "step", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRangeRequest {
    return new QueryRangeRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRangeRequest {
    return new QueryRangeRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRangeRequest {
    return new QueryRangeRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRangeRequest | PlainMessage<QueryRangeRequest> | undefined, b: QueryRangeRequest | PlainMessage<QueryRangeRequest> | undefined): boolean {
    return proto3.util.equals(QueryRangeRequest, a, b);
  }
}

/**
 * QueryRangeResponse is the set of matching profile values
 *
 * @generated from message parca.query.v1alpha1.QueryRangeResponse
 */
export class QueryRangeResponse extends Message<QueryRangeResponse> {
  /**
   * series is the set of metrics series that satisfy the query range request
   *
   * @generated from field: repeated parca.query.v1alpha1.MetricsSeries series = 1;
   */
  series: MetricsSeries[] = [];

  constructor(data?: PartialMessage<QueryRangeResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.QueryRangeResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "series", kind: "message", T: MetricsSeries, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRangeResponse {
    return new QueryRangeResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRangeResponse {
    return new QueryRangeResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRangeResponse {
    return new QueryRangeResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRangeResponse | PlainMessage<QueryRangeResponse> | undefined, b: QueryRangeResponse | PlainMessage<QueryRangeResponse> | undefined): boolean {
    return proto3.util.equals(QueryRangeResponse, a, b);
  }
}

/**
 * MetricsSeries is a set of labels and corresponding sample values
 *
 * @generated from message parca.query.v1alpha1.MetricsSeries
 */
export class MetricsSeries extends Message<MetricsSeries> {
  /**
   * labelset is the set of key value pairs
   *
   * @generated from field: parca.profilestore.v1alpha1.LabelSet labelset = 1;
   */
  labelset?: LabelSet;

  /**
   * samples is the set of top-level cumulative values of the corresponding profiles
   *
   * @generated from field: repeated parca.query.v1alpha1.MetricsSample samples = 2;
   */
  samples: MetricsSample[] = [];

  /**
   * period_type is the value type of profile period
   *
   * @generated from field: parca.query.v1alpha1.ValueType period_type = 3;
   */
  periodType?: ValueType;

  /**
   * sample_type is the value type of profile sample
   *
   * @generated from field: parca.query.v1alpha1.ValueType sample_type = 4;
   */
  sampleType?: ValueType;

  constructor(data?: PartialMessage<MetricsSeries>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.MetricsSeries";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "labelset", kind: "message", T: LabelSet },
    { no: 2, name: "samples", kind: "message", T: MetricsSample, repeated: true },
    { no: 3, name: "period_type", kind: "message", T: ValueType },
    { no: 4, name: "sample_type", kind: "message", T: ValueType },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsSeries {
    return new MetricsSeries().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsSeries {
    return new MetricsSeries().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsSeries {
    return new MetricsSeries().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsSeries | PlainMessage<MetricsSeries> | undefined, b: MetricsSeries | PlainMessage<MetricsSeries> | undefined): boolean {
    return proto3.util.equals(MetricsSeries, a, b);
  }
}

/**
 * MetricsSample is a cumulative value and timestamp of a profile
 *
 * @generated from message parca.query.v1alpha1.MetricsSample
 */
export class MetricsSample extends Message<MetricsSample> {
  /**
   * timestamp is the time the profile was ingested
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * value is the cumulative value for the profile
   *
   * @generated from field: int64 value = 2;
   */
  value = protoInt64.zero;

  /**
   * value_per_second is the calculated per second average in the steps duration
   *
   * @generated from field: double value_per_second = 3;
   */
  valuePerSecond = 0;

  /**
   * duration is the normalized aggregated duration the metric samples has been observed over.
   *
   * @generated from field: int64 duration = 4;
   */
  duration = protoInt64.zero;

  constructor(data?: PartialMessage<MetricsSample>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.MetricsSample";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "value", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "value_per_second", kind: "scalar", T: 1 /* ScalarType.DOUBLE */ },
    { no: 4, name: "duration", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MetricsSample {
    return new MetricsSample().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MetricsSample {
    return new MetricsSample().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MetricsSample {
    return new MetricsSample().fromJsonString(jsonString, options);
  }

  static equals(a: MetricsSample | PlainMessage<MetricsSample> | undefined, b: MetricsSample | PlainMessage<MetricsSample> | undefined): boolean {
    return proto3.util.equals(MetricsSample, a, b);
  }
}

/**
 * MergeProfile contains parameters for a merge request
 *
 * @generated from message parca.query.v1alpha1.MergeProfile
 */
export class MergeProfile extends Message<MergeProfile> {
  /**
   * query is the query string to match profiles for merge
   *
   * @generated from field: string query = 1;
   */
  query = "";

  /**
   * start is the beginning of the evaluation time window
   *
   * @generated from field: google.protobuf.Timestamp start = 2;
   */
  start?: Timestamp;

  /**
   * end is the end of the evaluation time window
   *
   * @generated from field: google.protobuf.Timestamp end = 3;
   */
  end?: Timestamp;

  constructor(data?: PartialMessage<MergeProfile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.MergeProfile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "start", kind: "message", T: Timestamp },
    { no: 3, name: "end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MergeProfile {
    return new MergeProfile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MergeProfile {
    return new MergeProfile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MergeProfile {
    return new MergeProfile().fromJsonString(jsonString, options);
  }

  static equals(a: MergeProfile | PlainMessage<MergeProfile> | undefined, b: MergeProfile | PlainMessage<MergeProfile> | undefined): boolean {
    return proto3.util.equals(MergeProfile, a, b);
  }
}

/**
 * SingleProfile contains parameters for a single profile query request
 *
 * @generated from message parca.query.v1alpha1.SingleProfile
 */
export class SingleProfile extends Message<SingleProfile> {
  /**
   * time is the point in time to perform the profile request
   *
   * @generated from field: google.protobuf.Timestamp time = 1;
   */
  time?: Timestamp;

  /**
   * query is the query string to retrieve the profile
   *
   * @generated from field: string query = 2;
   */
  query = "";

  constructor(data?: PartialMessage<SingleProfile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.SingleProfile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "time", kind: "message", T: Timestamp },
    { no: 2, name: "query", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SingleProfile {
    return new SingleProfile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SingleProfile {
    return new SingleProfile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SingleProfile {
    return new SingleProfile().fromJsonString(jsonString, options);
  }

  static equals(a: SingleProfile | PlainMessage<SingleProfile> | undefined, b: SingleProfile | PlainMessage<SingleProfile> | undefined): boolean {
    return proto3.util.equals(SingleProfile, a, b);
  }
}

/**
 * DiffProfile contains parameters for a profile diff request
 *
 * @generated from message parca.query.v1alpha1.DiffProfile
 */
export class DiffProfile extends Message<DiffProfile> {
  /**
   * a is the first profile to diff
   *
   * @generated from field: parca.query.v1alpha1.ProfileDiffSelection a = 1;
   */
  a?: ProfileDiffSelection;

  /**
   * b is the second profile to diff
   *
   * @generated from field: parca.query.v1alpha1.ProfileDiffSelection b = 2;
   */
  b?: ProfileDiffSelection;

  constructor(data?: PartialMessage<DiffProfile>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.DiffProfile";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "a", kind: "message", T: ProfileDiffSelection },
    { no: 2, name: "b", kind: "message", T: ProfileDiffSelection },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DiffProfile {
    return new DiffProfile().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DiffProfile {
    return new DiffProfile().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DiffProfile {
    return new DiffProfile().fromJsonString(jsonString, options);
  }

  static equals(a: DiffProfile | PlainMessage<DiffProfile> | undefined, b: DiffProfile | PlainMessage<DiffProfile> | undefined): boolean {
    return proto3.util.equals(DiffProfile, a, b);
  }
}

/**
 * ProfileDiffSelection contains the parameters of a diff selection
 *
 * @generated from message parca.query.v1alpha1.ProfileDiffSelection
 */
export class ProfileDiffSelection extends Message<ProfileDiffSelection> {
  /**
   * mode is the selection of the diff mode
   *
   * @generated from field: parca.query.v1alpha1.ProfileDiffSelection.Mode mode = 1;
   */
  mode = ProfileDiffSelection_Mode.SINGLE_UNSPECIFIED;

  /**
   * options are the available options for a diff selection
   *
   * @generated from oneof parca.query.v1alpha1.ProfileDiffSelection.options
   */
  options: {
    /**
     * merge contains options for a merge request
     *
     * @generated from field: parca.query.v1alpha1.MergeProfile merge = 2;
     */
    value: MergeProfile;
    case: "merge";
  } | {
    /**
     * single contains options for a single profile request
     *
     * @generated from field: parca.query.v1alpha1.SingleProfile single = 3;
     */
    value: SingleProfile;
    case: "single";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ProfileDiffSelection>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ProfileDiffSelection";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mode", kind: "enum", T: proto3.getEnumType(ProfileDiffSelection_Mode) },
    { no: 2, name: "merge", kind: "message", T: MergeProfile, oneof: "options" },
    { no: 3, name: "single", kind: "message", T: SingleProfile, oneof: "options" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ProfileDiffSelection {
    return new ProfileDiffSelection().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ProfileDiffSelection {
    return new ProfileDiffSelection().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ProfileDiffSelection {
    return new ProfileDiffSelection().fromJsonString(jsonString, options);
  }

  static equals(a: ProfileDiffSelection | PlainMessage<ProfileDiffSelection> | undefined, b: ProfileDiffSelection | PlainMessage<ProfileDiffSelection> | undefined): boolean {
    return proto3.util.equals(ProfileDiffSelection, a, b);
  }
}

/**
 * Mode specifies the type of diff
 *
 * @generated from enum parca.query.v1alpha1.ProfileDiffSelection.Mode
 */
export enum ProfileDiffSelection_Mode {
  /**
   * MODE_SINGLE_UNSPECIFIED default unspecified
   *
   * @generated from enum value: MODE_SINGLE_UNSPECIFIED = 0;
   */
  SINGLE_UNSPECIFIED = 0,

  /**
   * MODE_MERGE merge profile
   *
   * @generated from enum value: MODE_MERGE = 1;
   */
  MERGE = 1,
}
// Retrieve enum metadata with: proto3.getEnumType(ProfileDiffSelection_Mode)
proto3.util.setEnumType(ProfileDiffSelection_Mode, "parca.query.v1alpha1.ProfileDiffSelection.Mode", [
  { no: 0, name: "MODE_SINGLE_UNSPECIFIED" },
  { no: 1, name: "MODE_MERGE" },
]);

/**
 * QueryRequest is a request for a profile query
 *
 * @generated from message parca.query.v1alpha1.QueryRequest
 */
export class QueryRequest extends Message<QueryRequest> {
  /**
   * mode indicates the type of query performed
   *
   * @generated from field: parca.query.v1alpha1.QueryRequest.Mode mode = 1;
   */
  mode = QueryRequest_Mode.SINGLE_UNSPECIFIED;

  /**
   * options are the options corresponding to the mode
   *
   * @generated from oneof parca.query.v1alpha1.QueryRequest.options
   */
  options: {
    /**
     * diff contains the diff query options
     *
     * @generated from field: parca.query.v1alpha1.DiffProfile diff = 2;
     */
    value: DiffProfile;
    case: "diff";
  } | {
    /**
     * merge contains the merge query options
     *
     * @generated from field: parca.query.v1alpha1.MergeProfile merge = 3;
     */
    value: MergeProfile;
    case: "merge";
  } | {
    /**
     * single contains the single query options
     *
     * @generated from field: parca.query.v1alpha1.SingleProfile single = 4;
     */
    value: SingleProfile;
    case: "single";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * report_type is the type of report to return
   *
   * @generated from field: parca.query.v1alpha1.QueryRequest.ReportType report_type = 5;
   */
  reportType = QueryRequest_ReportType.FLAMEGRAPH_UNSPECIFIED;

  /**
   * filter_query is the query string to filter the profile samples
   *
   * @generated from field: optional string filter_query = 6;
   */
  filterQuery?: string;

  /**
   * node_trim_threshold is the threshold % where the nodes with Value less than this will be removed from the report
   *
   * @generated from field: optional float node_trim_threshold = 7;
   */
  nodeTrimThreshold?: number;

  constructor(data?: PartialMessage<QueryRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.QueryRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "mode", kind: "enum", T: proto3.getEnumType(QueryRequest_Mode) },
    { no: 2, name: "diff", kind: "message", T: DiffProfile, oneof: "options" },
    { no: 3, name: "merge", kind: "message", T: MergeProfile, oneof: "options" },
    { no: 4, name: "single", kind: "message", T: SingleProfile, oneof: "options" },
    { no: 5, name: "report_type", kind: "enum", T: proto3.getEnumType(QueryRequest_ReportType) },
    { no: 6, name: "filter_query", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
    { no: 7, name: "node_trim_threshold", kind: "scalar", T: 2 /* ScalarType.FLOAT */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryRequest {
    return new QueryRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryRequest {
    return new QueryRequest().fromJsonString(jsonString, options);
  }

  static equals(a: QueryRequest | PlainMessage<QueryRequest> | undefined, b: QueryRequest | PlainMessage<QueryRequest> | undefined): boolean {
    return proto3.util.equals(QueryRequest, a, b);
  }
}

/**
 * Mode is the type of query request
 *
 * @generated from enum parca.query.v1alpha1.QueryRequest.Mode
 */
export enum QueryRequest_Mode {
  /**
   * MODE_SINGLE_UNSPECIFIED query unspecified
   *
   * @generated from enum value: MODE_SINGLE_UNSPECIFIED = 0;
   */
  SINGLE_UNSPECIFIED = 0,

  /**
   * MODE_DIFF is a diff query
   *
   * @generated from enum value: MODE_DIFF = 1;
   */
  DIFF = 1,

  /**
   * MODE_MERGE is a merge query
   *
   * @generated from enum value: MODE_MERGE = 2;
   */
  MERGE = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryRequest_Mode)
proto3.util.setEnumType(QueryRequest_Mode, "parca.query.v1alpha1.QueryRequest.Mode", [
  { no: 0, name: "MODE_SINGLE_UNSPECIFIED" },
  { no: 1, name: "MODE_DIFF" },
  { no: 2, name: "MODE_MERGE" },
]);

/**
 * ReportType is the type of report to return
 *
 * @generated from enum parca.query.v1alpha1.QueryRequest.ReportType
 */
export enum QueryRequest_ReportType {
  /**
   * REPORT_TYPE_FLAMEGRAPH_UNSPECIFIED unspecified
   *
   * @generated from enum value: REPORT_TYPE_FLAMEGRAPH_UNSPECIFIED = 0 [deprecated = true];
   * @deprecated
   */
  FLAMEGRAPH_UNSPECIFIED = 0,

  /**
   * REPORT_TYPE_PPROF unspecified
   *
   * @generated from enum value: REPORT_TYPE_PPROF = 1;
   */
  PPROF = 1,

  /**
   * REPORT_TYPE_TOP unspecified
   *
   * @generated from enum value: REPORT_TYPE_TOP = 2;
   */
  TOP = 2,

  /**
   * REPORT_TYPE_CALLGRAPH unspecified
   *
   * @generated from enum value: REPORT_TYPE_CALLGRAPH = 3;
   */
  CALLGRAPH = 3,

  /**
   * REPORT_TYPE_FLAMEGRAPH_TABLE unspecified
   *
   * @generated from enum value: REPORT_TYPE_FLAMEGRAPH_TABLE = 4;
   */
  FLAMEGRAPH_TABLE = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(QueryRequest_ReportType)
proto3.util.setEnumType(QueryRequest_ReportType, "parca.query.v1alpha1.QueryRequest.ReportType", [
  { no: 0, name: "REPORT_TYPE_FLAMEGRAPH_UNSPECIFIED" },
  { no: 1, name: "REPORT_TYPE_PPROF" },
  { no: 2, name: "REPORT_TYPE_TOP" },
  { no: 3, name: "REPORT_TYPE_CALLGRAPH" },
  { no: 4, name: "REPORT_TYPE_FLAMEGRAPH_TABLE" },
]);

/**
 * Top is the top report type
 *
 * @generated from message parca.query.v1alpha1.Top
 */
export class Top extends Message<Top> {
  /**
   * list are the list of ordered elements of the table
   *
   * @generated from field: repeated parca.query.v1alpha1.TopNode list = 1;
   */
  list: TopNode[] = [];

  /**
   * reported is the number of lines reported
   *
   * @generated from field: int32 reported = 2;
   */
  reported = 0;

  /**
   * total is the number of lines that exist in the report
   * Use total from the top level query response instead.
   *
   * @generated from field: int32 total = 3 [deprecated = true];
   * @deprecated
   */
  total = 0;

  /**
   * unit is the unit represented by top table
   *
   * @generated from field: string unit = 4;
   */
  unit = "";

  constructor(data?: PartialMessage<Top>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.Top";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "list", kind: "message", T: TopNode, repeated: true },
    { no: 2, name: "reported", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "total", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 4, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Top {
    return new Top().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Top {
    return new Top().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Top {
    return new Top().fromJsonString(jsonString, options);
  }

  static equals(a: Top | PlainMessage<Top> | undefined, b: Top | PlainMessage<Top> | undefined): boolean {
    return proto3.util.equals(Top, a, b);
  }
}

/**
 * TopNode is a node entry in a top list
 *
 * @generated from message parca.query.v1alpha1.TopNode
 */
export class TopNode extends Message<TopNode> {
  /**
   * meta is the metadata about the node
   *
   * @generated from field: parca.query.v1alpha1.TopNodeMeta meta = 1;
   */
  meta?: TopNodeMeta;

  /**
   * cumulative is the cumulative value of the node
   *
   * @generated from field: int64 cumulative = 2;
   */
  cumulative = protoInt64.zero;

  /**
   * flat is the flat value of the node
   *
   * @generated from field: int64 flat = 3;
   */
  flat = protoInt64.zero;

  /**
   * diff is the diff value between two profiles
   *
   * @generated from field: int64 diff = 4;
   */
  diff = protoInt64.zero;

  constructor(data?: PartialMessage<TopNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.TopNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: TopNodeMeta },
    { no: 2, name: "cumulative", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "flat", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "diff", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopNode {
    return new TopNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopNode {
    return new TopNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopNode {
    return new TopNode().fromJsonString(jsonString, options);
  }

  static equals(a: TopNode | PlainMessage<TopNode> | undefined, b: TopNode | PlainMessage<TopNode> | undefined): boolean {
    return proto3.util.equals(TopNode, a, b);
  }
}

/**
 * TopNodeMeta is the metadata for a given node
 *
 * @generated from message parca.query.v1alpha1.TopNodeMeta
 */
export class TopNodeMeta extends Message<TopNodeMeta> {
  /**
   * location is the location for the code
   *
   * @generated from field: parca.metastore.v1alpha1.Location location = 1;
   */
  location?: Location;

  /**
   * mapping is the mapping into code
   *
   * @generated from field: parca.metastore.v1alpha1.Mapping mapping = 2;
   */
  mapping?: Mapping;

  /**
   * function is the function information
   *
   * @generated from field: parca.metastore.v1alpha1.Function function = 3;
   */
  function?: Function;

  /**
   * line is the line location
   *
   * @generated from field: parca.metastore.v1alpha1.Line line = 4;
   */
  line?: Line;

  constructor(data?: PartialMessage<TopNodeMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.TopNodeMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "message", T: Location },
    { no: 2, name: "mapping", kind: "message", T: Mapping },
    { no: 3, name: "function", kind: "message", T: Function },
    { no: 4, name: "line", kind: "message", T: Line },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TopNodeMeta {
    return new TopNodeMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TopNodeMeta {
    return new TopNodeMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TopNodeMeta {
    return new TopNodeMeta().fromJsonString(jsonString, options);
  }

  static equals(a: TopNodeMeta | PlainMessage<TopNodeMeta> | undefined, b: TopNodeMeta | PlainMessage<TopNodeMeta> | undefined): boolean {
    return proto3.util.equals(TopNodeMeta, a, b);
  }
}

/**
 * Flamegraph is the flame graph report type
 *
 * @generated from message parca.query.v1alpha1.Flamegraph
 */
export class Flamegraph extends Message<Flamegraph> {
  /**
   * root is the root of the flame graph
   *
   * @generated from field: parca.query.v1alpha1.FlamegraphRootNode root = 1;
   */
  root?: FlamegraphRootNode;

  /**
   * total is the total weight of the flame graph
   * Use total from the top level query response instead.
   *
   * @generated from field: int64 total = 2 [deprecated = true];
   * @deprecated
   */
  total = protoInt64.zero;

  /**
   * unit is the unit represented by the flame graph
   *
   * @generated from field: string unit = 3;
   */
  unit = "";

  /**
   * height is the max height of the graph
   *
   * @generated from field: int32 height = 4;
   */
  height = 0;

  /**
   * string_table holds all deduplicated strings used in the meta data.
   *
   * @generated from field: repeated string string_table = 5;
   */
  stringTable: string[] = [];

  /**
   * locations deduplicated by their ID to be referenced by nodes.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Location locations = 6;
   */
  locations: Location[] = [];

  /**
   * mapping deduplicated by their ID to be referenced by nodes.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Mapping mapping = 7;
   */
  mapping: Mapping[] = [];

  /**
   * function deduplicated by their ID to be referenced by nodes.
   *
   * @generated from field: repeated parca.metastore.v1alpha1.Function function = 8;
   */
  function: Function[] = [];

  /**
   * untrimmed_total is the total weight of the flame graph before trimming.
   * Use trimmed instead.
   *
   * @generated from field: int64 untrimmed_total = 9 [deprecated = true];
   * @deprecated
   */
  untrimmedTotal = protoInt64.zero;

  /**
   * trimmed is the amount of cumulative value trimmed from the flame graph.
   *
   * @generated from field: int64 trimmed = 10;
   */
  trimmed = protoInt64.zero;

  constructor(data?: PartialMessage<Flamegraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.Flamegraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root", kind: "message", T: FlamegraphRootNode },
    { no: 2, name: "total", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "height", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 5, name: "string_table", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 6, name: "locations", kind: "message", T: Location, repeated: true },
    { no: 7, name: "mapping", kind: "message", T: Mapping, repeated: true },
    { no: 8, name: "function", kind: "message", T: Function, repeated: true },
    { no: 9, name: "untrimmed_total", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "trimmed", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Flamegraph {
    return new Flamegraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Flamegraph {
    return new Flamegraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Flamegraph {
    return new Flamegraph().fromJsonString(jsonString, options);
  }

  static equals(a: Flamegraph | PlainMessage<Flamegraph> | undefined, b: Flamegraph | PlainMessage<Flamegraph> | undefined): boolean {
    return proto3.util.equals(Flamegraph, a, b);
  }
}

/**
 * FlamegraphRootNode is a root node of a flame graph
 *
 * @generated from message parca.query.v1alpha1.FlamegraphRootNode
 */
export class FlamegraphRootNode extends Message<FlamegraphRootNode> {
  /**
   * cumulative is the cumulative value of the graph
   *
   * @generated from field: int64 cumulative = 1;
   */
  cumulative = protoInt64.zero;

  /**
   * diff is the diff
   *
   * @generated from field: int64 diff = 2;
   */
  diff = protoInt64.zero;

  /**
   * children are the list of the children of the root node
   *
   * @generated from field: repeated parca.query.v1alpha1.FlamegraphNode children = 3;
   */
  children: FlamegraphNode[] = [];

  constructor(data?: PartialMessage<FlamegraphRootNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.FlamegraphRootNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "cumulative", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 2, name: "diff", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "children", kind: "message", T: FlamegraphNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlamegraphRootNode {
    return new FlamegraphRootNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlamegraphRootNode {
    return new FlamegraphRootNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlamegraphRootNode {
    return new FlamegraphRootNode().fromJsonString(jsonString, options);
  }

  static equals(a: FlamegraphRootNode | PlainMessage<FlamegraphRootNode> | undefined, b: FlamegraphRootNode | PlainMessage<FlamegraphRootNode> | undefined): boolean {
    return proto3.util.equals(FlamegraphRootNode, a, b);
  }
}

/**
 * FlamegraphNode represents a node in the graph
 *
 * @generated from message parca.query.v1alpha1.FlamegraphNode
 */
export class FlamegraphNode extends Message<FlamegraphNode> {
  /**
   * meta is the metadata about the node
   *
   * @generated from field: parca.query.v1alpha1.FlamegraphNodeMeta meta = 1;
   */
  meta?: FlamegraphNodeMeta;

  /**
   * cumulative is the cumulative value of the node
   *
   * @generated from field: int64 cumulative = 2;
   */
  cumulative = protoInt64.zero;

  /**
   * diff is the diff
   *
   * @generated from field: int64 diff = 3;
   */
  diff = protoInt64.zero;

  /**
   * children are the child nodes
   *
   * @generated from field: repeated parca.query.v1alpha1.FlamegraphNode children = 4;
   */
  children: FlamegraphNode[] = [];

  constructor(data?: PartialMessage<FlamegraphNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.FlamegraphNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "meta", kind: "message", T: FlamegraphNodeMeta },
    { no: 2, name: "cumulative", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 3, name: "diff", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "children", kind: "message", T: FlamegraphNode, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlamegraphNode {
    return new FlamegraphNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlamegraphNode {
    return new FlamegraphNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlamegraphNode {
    return new FlamegraphNode().fromJsonString(jsonString, options);
  }

  static equals(a: FlamegraphNode | PlainMessage<FlamegraphNode> | undefined, b: FlamegraphNode | PlainMessage<FlamegraphNode> | undefined): boolean {
    return proto3.util.equals(FlamegraphNode, a, b);
  }
}

/**
 * FlamegraphNodeMeta is the metadata for a given node
 *
 * @generated from message parca.query.v1alpha1.FlamegraphNodeMeta
 */
export class FlamegraphNodeMeta extends Message<FlamegraphNodeMeta> {
  /**
   * location is the location for the code
   *
   * @generated from field: parca.metastore.v1alpha1.Location location = 1;
   */
  location?: Location;

  /**
   * mapping is the mapping into code
   *
   * @generated from field: parca.metastore.v1alpha1.Mapping mapping = 2;
   */
  mapping?: Mapping;

  /**
   * function is the function information
   *
   * @generated from field: parca.metastore.v1alpha1.Function function = 3;
   */
  function?: Function;

  /**
   * line is the line location
   *
   * @generated from field: parca.metastore.v1alpha1.Line line = 4;
   */
  line?: Line;

  /**
   * location_index has the index to the deduplicated location in the location table.
   *
   * @generated from field: uint32 location_index = 5;
   */
  locationIndex = 0;

  /**
   * line_index is the line index within the referenced location.
   *
   * @generated from field: uint32 line_index = 6;
   */
  lineIndex = 0;

  constructor(data?: PartialMessage<FlamegraphNodeMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.FlamegraphNodeMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "message", T: Location },
    { no: 2, name: "mapping", kind: "message", T: Mapping },
    { no: 3, name: "function", kind: "message", T: Function },
    { no: 4, name: "line", kind: "message", T: Line },
    { no: 5, name: "location_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "line_index", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FlamegraphNodeMeta {
    return new FlamegraphNodeMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FlamegraphNodeMeta {
    return new FlamegraphNodeMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FlamegraphNodeMeta {
    return new FlamegraphNodeMeta().fromJsonString(jsonString, options);
  }

  static equals(a: FlamegraphNodeMeta | PlainMessage<FlamegraphNodeMeta> | undefined, b: FlamegraphNodeMeta | PlainMessage<FlamegraphNodeMeta> | undefined): boolean {
    return proto3.util.equals(FlamegraphNodeMeta, a, b);
  }
}

/**
 * CallgraphNode represents a node in the graph
 *
 * @generated from message parca.query.v1alpha1.CallgraphNode
 */
export class CallgraphNode extends Message<CallgraphNode> {
  /**
   * id is the unique id of the node
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * meta is the metadata about the node
   *
   * @generated from field: parca.query.v1alpha1.CallgraphNodeMeta meta = 2;
   */
  meta?: CallgraphNodeMeta;

  /**
   * cumulative is the cumulative value of the node
   *
   * @generated from field: int64 cumulative = 3;
   */
  cumulative = protoInt64.zero;

  /**
   * flat is the flat value of the node
   *
   * @generated from field: int64 flat = 4;
   */
  flat = protoInt64.zero;

  constructor(data?: PartialMessage<CallgraphNode>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.CallgraphNode";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "meta", kind: "message", T: CallgraphNodeMeta },
    { no: 3, name: "cumulative", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 4, name: "flat", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallgraphNode {
    return new CallgraphNode().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallgraphNode {
    return new CallgraphNode().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallgraphNode {
    return new CallgraphNode().fromJsonString(jsonString, options);
  }

  static equals(a: CallgraphNode | PlainMessage<CallgraphNode> | undefined, b: CallgraphNode | PlainMessage<CallgraphNode> | undefined): boolean {
    return proto3.util.equals(CallgraphNode, a, b);
  }
}

/**
 * TopNodeMeta is the metadata for a given node
 *
 * @generated from message parca.query.v1alpha1.CallgraphNodeMeta
 */
export class CallgraphNodeMeta extends Message<CallgraphNodeMeta> {
  /**
   * location is the location for the code
   *
   * @generated from field: parca.metastore.v1alpha1.Location location = 1;
   */
  location?: Location;

  /**
   * mapping is the mapping into code
   *
   * @generated from field: parca.metastore.v1alpha1.Mapping mapping = 2;
   */
  mapping?: Mapping;

  /**
   * function is the function information
   *
   * @generated from field: parca.metastore.v1alpha1.Function function = 3;
   */
  function?: Function;

  /**
   * line is the line location
   *
   * @generated from field: parca.metastore.v1alpha1.Line line = 4;
   */
  line?: Line;

  constructor(data?: PartialMessage<CallgraphNodeMeta>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.CallgraphNodeMeta";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "location", kind: "message", T: Location },
    { no: 2, name: "mapping", kind: "message", T: Mapping },
    { no: 3, name: "function", kind: "message", T: Function },
    { no: 4, name: "line", kind: "message", T: Line },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallgraphNodeMeta {
    return new CallgraphNodeMeta().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallgraphNodeMeta {
    return new CallgraphNodeMeta().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallgraphNodeMeta {
    return new CallgraphNodeMeta().fromJsonString(jsonString, options);
  }

  static equals(a: CallgraphNodeMeta | PlainMessage<CallgraphNodeMeta> | undefined, b: CallgraphNodeMeta | PlainMessage<CallgraphNodeMeta> | undefined): boolean {
    return proto3.util.equals(CallgraphNodeMeta, a, b);
  }
}

/**
 * CallgraphEdge represents an edge in the graph
 *
 * @generated from message parca.query.v1alpha1.CallgraphEdge
 */
export class CallgraphEdge extends Message<CallgraphEdge> {
  /**
   * id is the unique id of the edge
   *
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * source represents the id of the source node
   *
   * @generated from field: string source = 2;
   */
  source = "";

  /**
   * target represents the id of the target node
   *
   * @generated from field: string target = 3;
   */
  target = "";

  /**
   * cumulative is the cumulative value of the edge
   *
   * @generated from field: int64 cumulative = 4;
   */
  cumulative = protoInt64.zero;

  /**
   * is_collapsed indicates if the edge is collapsed
   *
   * @generated from field: bool is_collapsed = 5;
   */
  isCollapsed = false;

  constructor(data?: PartialMessage<CallgraphEdge>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.CallgraphEdge";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "source", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "target", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "cumulative", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 5, name: "is_collapsed", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CallgraphEdge {
    return new CallgraphEdge().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CallgraphEdge {
    return new CallgraphEdge().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CallgraphEdge {
    return new CallgraphEdge().fromJsonString(jsonString, options);
  }

  static equals(a: CallgraphEdge | PlainMessage<CallgraphEdge> | undefined, b: CallgraphEdge | PlainMessage<CallgraphEdge> | undefined): boolean {
    return proto3.util.equals(CallgraphEdge, a, b);
  }
}

/**
 * Callgraph is the callgraph report type
 *
 * @generated from message parca.query.v1alpha1.Callgraph
 */
export class Callgraph extends Message<Callgraph> {
  /**
   * nodes are the nodes in the callgraph
   *
   * @generated from field: repeated parca.query.v1alpha1.CallgraphNode nodes = 1;
   */
  nodes: CallgraphNode[] = [];

  /**
   * edges are the edges connecting nodes in the callgraph
   *
   * @generated from field: repeated parca.query.v1alpha1.CallgraphEdge edges = 2;
   */
  edges: CallgraphEdge[] = [];

  /**
   * cumulative is the total cumulative value of the callgraph
   * Use total from the top level query response instead.
   *
   * @generated from field: int64 cumulative = 3 [deprecated = true];
   * @deprecated
   */
  cumulative = protoInt64.zero;

  constructor(data?: PartialMessage<Callgraph>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.Callgraph";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nodes", kind: "message", T: CallgraphNode, repeated: true },
    { no: 2, name: "edges", kind: "message", T: CallgraphEdge, repeated: true },
    { no: 3, name: "cumulative", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Callgraph {
    return new Callgraph().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Callgraph {
    return new Callgraph().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Callgraph {
    return new Callgraph().fromJsonString(jsonString, options);
  }

  static equals(a: Callgraph | PlainMessage<Callgraph> | undefined, b: Callgraph | PlainMessage<Callgraph> | undefined): boolean {
    return proto3.util.equals(Callgraph, a, b);
  }
}

/**
 * QueryResponse is the returned report for the given query
 *
 * @generated from message parca.query.v1alpha1.QueryResponse
 */
export class QueryResponse extends Message<QueryResponse> {
  /**
   * report is the generated report
   *
   * @generated from oneof parca.query.v1alpha1.QueryResponse.report
   */
  report: {
    /**
     * flamegraph is a flamegraph representation of the report
     *
     * @generated from field: parca.query.v1alpha1.Flamegraph flamegraph = 5;
     */
    value: Flamegraph;
    case: "flamegraph";
  } | {
    /**
     * pprof is a pprof profile as compressed bytes
     *
     * @generated from field: bytes pprof = 6;
     */
    value: Uint8Array;
    case: "pprof";
  } | {
    /**
     * top is a top list representation of the report
     *
     * @generated from field: parca.query.v1alpha1.Top top = 7;
     */
    value: Top;
    case: "top";
  } | {
    /**
     * callgraph is a callgraph nodes and edges representation of the report
     *
     * @generated from field: parca.query.v1alpha1.Callgraph callgraph = 8;
     */
    value: Callgraph;
    case: "callgraph";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * total is the total number of samples shown in the report.
   *
   * @generated from field: int64 total = 9;
   */
  total = protoInt64.zero;

  /**
   * filtered is the number of samples filtered out of the report.
   *
   * @generated from field: int64 filtered = 10;
   */
  filtered = protoInt64.zero;

  constructor(data?: PartialMessage<QueryResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.QueryResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 5, name: "flamegraph", kind: "message", T: Flamegraph, oneof: "report" },
    { no: 6, name: "pprof", kind: "scalar", T: 12 /* ScalarType.BYTES */, oneof: "report" },
    { no: 7, name: "top", kind: "message", T: Top, oneof: "report" },
    { no: 8, name: "callgraph", kind: "message", T: Callgraph, oneof: "report" },
    { no: 9, name: "total", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
    { no: 10, name: "filtered", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryResponse {
    return new QueryResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryResponse {
    return new QueryResponse().fromJsonString(jsonString, options);
  }

  static equals(a: QueryResponse | PlainMessage<QueryResponse> | undefined, b: QueryResponse | PlainMessage<QueryResponse> | undefined): boolean {
    return proto3.util.equals(QueryResponse, a, b);
  }
}

/**
 * SeriesRequest is unimplemented
 *
 * @generated from message parca.query.v1alpha1.SeriesRequest
 */
export class SeriesRequest extends Message<SeriesRequest> {
  /**
   * match ...
   *
   * @generated from field: repeated string match = 1;
   */
  match: string[] = [];

  /**
   * start ...
   *
   * @generated from field: google.protobuf.Timestamp start = 2;
   */
  start?: Timestamp;

  /**
   * end ...
   *
   * @generated from field: google.protobuf.Timestamp end = 3;
   */
  end?: Timestamp;

  constructor(data?: PartialMessage<SeriesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.SeriesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "start", kind: "message", T: Timestamp },
    { no: 3, name: "end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeriesRequest {
    return new SeriesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeriesRequest {
    return new SeriesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeriesRequest {
    return new SeriesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SeriesRequest | PlainMessage<SeriesRequest> | undefined, b: SeriesRequest | PlainMessage<SeriesRequest> | undefined): boolean {
    return proto3.util.equals(SeriesRequest, a, b);
  }
}

/**
 * SeriesResponse is unimplemented
 *
 * @generated from message parca.query.v1alpha1.SeriesResponse
 */
export class SeriesResponse extends Message<SeriesResponse> {
  constructor(data?: PartialMessage<SeriesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.SeriesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SeriesResponse {
    return new SeriesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SeriesResponse {
    return new SeriesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SeriesResponse {
    return new SeriesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SeriesResponse | PlainMessage<SeriesResponse> | undefined, b: SeriesResponse | PlainMessage<SeriesResponse> | undefined): boolean {
    return proto3.util.equals(SeriesResponse, a, b);
  }
}

/**
 * LabelsRequest are the request values for labels
 *
 * @generated from message parca.query.v1alpha1.LabelsRequest
 */
export class LabelsRequest extends Message<LabelsRequest> {
  /**
   * match are the set of matching strings
   *
   * @generated from field: repeated string match = 1;
   */
  match: string[] = [];

  /**
   * start is the start of the time window to perform the query
   *
   * @generated from field: google.protobuf.Timestamp start = 2;
   */
  start?: Timestamp;

  /**
   * end is the end of the time window to perform the query
   *
   * @generated from field: google.protobuf.Timestamp end = 3;
   */
  end?: Timestamp;

  constructor(data?: PartialMessage<LabelsRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.LabelsRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "match", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "start", kind: "message", T: Timestamp },
    { no: 3, name: "end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelsRequest {
    return new LabelsRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelsRequest {
    return new LabelsRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelsRequest {
    return new LabelsRequest().fromJsonString(jsonString, options);
  }

  static equals(a: LabelsRequest | PlainMessage<LabelsRequest> | undefined, b: LabelsRequest | PlainMessage<LabelsRequest> | undefined): boolean {
    return proto3.util.equals(LabelsRequest, a, b);
  }
}

/**
 * LabelsResponse is the set of matching label names
 *
 * @generated from message parca.query.v1alpha1.LabelsResponse
 */
export class LabelsResponse extends Message<LabelsResponse> {
  /**
   * / label_names are the set of matching label names
   *
   * @generated from field: repeated string label_names = 1;
   */
  labelNames: string[] = [];

  /**
   * warnings is unimplemented
   *
   * @generated from field: repeated string warnings = 2;
   */
  warnings: string[] = [];

  constructor(data?: PartialMessage<LabelsResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.LabelsResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "warnings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): LabelsResponse {
    return new LabelsResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): LabelsResponse {
    return new LabelsResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): LabelsResponse {
    return new LabelsResponse().fromJsonString(jsonString, options);
  }

  static equals(a: LabelsResponse | PlainMessage<LabelsResponse> | undefined, b: LabelsResponse | PlainMessage<LabelsResponse> | undefined): boolean {
    return proto3.util.equals(LabelsResponse, a, b);
  }
}

/**
 * ValuesRequest are the request values for a values request
 *
 * @generated from message parca.query.v1alpha1.ValuesRequest
 */
export class ValuesRequest extends Message<ValuesRequest> {
  /**
   * label_name is the label name to match values against
   *
   * @generated from field: string label_name = 1;
   */
  labelName = "";

  /**
   * match are the set of matching strings to match values against
   *
   * @generated from field: repeated string match = 2;
   */
  match: string[] = [];

  /**
   * start is the start of the time window to perform the query
   *
   * @generated from field: google.protobuf.Timestamp start = 3;
   */
  start?: Timestamp;

  /**
   * end is the end of the time window to perform the query
   *
   * @generated from field: google.protobuf.Timestamp end = 4;
   */
  end?: Timestamp;

  constructor(data?: PartialMessage<ValuesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ValuesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "match", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "start", kind: "message", T: Timestamp },
    { no: 4, name: "end", kind: "message", T: Timestamp },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValuesRequest {
    return new ValuesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValuesRequest {
    return new ValuesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValuesRequest {
    return new ValuesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ValuesRequest | PlainMessage<ValuesRequest> | undefined, b: ValuesRequest | PlainMessage<ValuesRequest> | undefined): boolean {
    return proto3.util.equals(ValuesRequest, a, b);
  }
}

/**
 * ValuesResponse are the set of matching values
 *
 * @generated from message parca.query.v1alpha1.ValuesResponse
 */
export class ValuesResponse extends Message<ValuesResponse> {
  /**
   * label_values are the set of matching label values
   *
   * @generated from field: repeated string label_values = 1;
   */
  labelValues: string[] = [];

  /**
   * warnings is unimplemented
   *
   * @generated from field: repeated string warnings = 2;
   */
  warnings: string[] = [];

  constructor(data?: PartialMessage<ValuesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ValuesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "label_values", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 2, name: "warnings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValuesResponse {
    return new ValuesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValuesResponse {
    return new ValuesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValuesResponse {
    return new ValuesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ValuesResponse | PlainMessage<ValuesResponse> | undefined, b: ValuesResponse | PlainMessage<ValuesResponse> | undefined): boolean {
    return proto3.util.equals(ValuesResponse, a, b);
  }
}

/**
 * ValueType represents a value, including its type and unit
 *
 * @generated from message parca.query.v1alpha1.ValueType
 */
export class ValueType extends Message<ValueType> {
  /**
   * type is the type of the value
   *
   * @generated from field: string type = 1;
   */
  type = "";

  /**
   * unit is the unit of the value
   *
   * @generated from field: string unit = 2;
   */
  unit = "";

  constructor(data?: PartialMessage<ValueType>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ValueType";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "type", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "unit", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueType {
    return new ValueType().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueType {
    return new ValueType().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueType {
    return new ValueType().fromJsonString(jsonString, options);
  }

  static equals(a: ValueType | PlainMessage<ValueType> | undefined, b: ValueType | PlainMessage<ValueType> | undefined): boolean {
    return proto3.util.equals(ValueType, a, b);
  }
}

/**
 * ShareProfileRequest represents the query denoting the profile and a description about the profile
 *
 * @generated from message parca.query.v1alpha1.ShareProfileRequest
 */
export class ShareProfileRequest extends Message<ShareProfileRequest> {
  /**
   * QueryRequest that refers to the profile to be shared
   *
   * @generated from field: parca.query.v1alpha1.QueryRequest query_request = 1;
   */
  queryRequest?: QueryRequest;

  /**
   * description about the profile
   *
   * @generated from field: optional string description = 2;
   */
  description?: string;

  constructor(data?: PartialMessage<ShareProfileRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ShareProfileRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_request", kind: "message", T: QueryRequest },
    { no: 2, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */, opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShareProfileRequest {
    return new ShareProfileRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShareProfileRequest {
    return new ShareProfileRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShareProfileRequest {
    return new ShareProfileRequest().fromJsonString(jsonString, options);
  }

  static equals(a: ShareProfileRequest | PlainMessage<ShareProfileRequest> | undefined, b: ShareProfileRequest | PlainMessage<ShareProfileRequest> | undefined): boolean {
    return proto3.util.equals(ShareProfileRequest, a, b);
  }
}

/**
 * ShareProfileResponse represents the shared link of a profile
 *
 * @generated from message parca.query.v1alpha1.ShareProfileResponse
 */
export class ShareProfileResponse extends Message<ShareProfileResponse> {
  /**
   * link to access the profile
   *
   * @generated from field: string link = 1;
   */
  link = "";

  constructor(data?: PartialMessage<ShareProfileResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "parca.query.v1alpha1.ShareProfileResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "link", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ShareProfileResponse {
    return new ShareProfileResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ShareProfileResponse {
    return new ShareProfileResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ShareProfileResponse {
    return new ShareProfileResponse().fromJsonString(jsonString, options);
  }

  static equals(a: ShareProfileResponse | PlainMessage<ShareProfileResponse> | undefined, b: ShareProfileResponse | PlainMessage<ShareProfileResponse> | undefined): boolean {
    return proto3.util.equals(ShareProfileResponse, a, b);
  }
}

