// Code generated by protoc-gen-connect-go. DO NOT EDIT.
//
// Source: parca/metastore/v1alpha1/metastore.proto

package metastorev1alpha1connect

import (
	context "context"
	errors "errors"
	connect_go "github.com/bufbuild/connect-go"
	v1alpha1 "github.com/parca-dev/parca/gen/proto/go/parca/metastore/v1alpha1"
	http "net/http"
	strings "strings"
)

// This is a compile-time assertion to ensure that this generated file and the connect package are
// compatible. If you get a compiler error that this constant is not defined, this code was
// generated with a version of connect newer than the one compiled into your binary. You can fix the
// problem by either regenerating this code with an older version of connect or updating the connect
// version compiled into your binary.
const _ = connect_go.IsAtLeastVersion0_1_0

const (
	// MetastoreServiceName is the fully-qualified name of the MetastoreService service.
	MetastoreServiceName = "parca.metastore.v1alpha1.MetastoreService"
)

// MetastoreServiceClient is a client for the parca.metastore.v1alpha1.MetastoreService service.
type MetastoreServiceClient interface {
	// GetOrCreateMappings checks if the mappings in the request are already
	// known and returns the known mapping (including its ID) if so. If a mapping
	// does not already exist, it is written to the backing metastore.
	GetOrCreateMappings(context.Context, *connect_go.Request[v1alpha1.GetOrCreateMappingsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateMappingsResponse], error)
	// GetOrCreateFunctions checks if the functions in the request are already
	// known and returns the known function (including its ID) if so. If a
	// function does not already exist, it is written to the backing metastore.
	GetOrCreateFunctions(context.Context, *connect_go.Request[v1alpha1.GetOrCreateFunctionsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateFunctionsResponse], error)
	// GetOrCreateLocations checks if the locations in the request are already
	// known and returns the known location (including its ID) if so. If a
	// location does not already exist, it is written to the backing metastore.
	GetOrCreateLocations(context.Context, *connect_go.Request[v1alpha1.GetOrCreateLocationsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateLocationsResponse], error)
	// GetOrCreateStacktraces checks if the stacktraces in the request are
	// already known and returns the known stacktrace (including its ID) if so.
	// If a stacktrace does not already exist, it is written to the backing
	// metastore.
	GetOrCreateStacktraces(context.Context, *connect_go.Request[v1alpha1.GetOrCreateStacktracesRequest]) (*connect_go.Response[v1alpha1.GetOrCreateStacktracesResponse], error)
	// UnsymbolizedLocations returns locations that can be symbolized but haven't
	// been asynchronously symbolized yet.
	UnsymbolizedLocations(context.Context, *connect_go.Request[v1alpha1.UnsymbolizedLocationsRequest]) (*connect_go.Response[v1alpha1.UnsymbolizedLocationsResponse], error)
	// CreateLocationLines creates the location lines contained in the provided
	// locations.
	CreateLocationLines(context.Context, *connect_go.Request[v1alpha1.CreateLocationLinesRequest]) (*connect_go.Response[v1alpha1.CreateLocationLinesResponse], error)
	// Locations retrieves locations.
	Locations(context.Context, *connect_go.Request[v1alpha1.LocationsRequest]) (*connect_go.Response[v1alpha1.LocationsResponse], error)
	// Functions retrieves functions.
	Functions(context.Context, *connect_go.Request[v1alpha1.FunctionsRequest]) (*connect_go.Response[v1alpha1.FunctionsResponse], error)
	// Mappings retrieves mappings.
	Mappings(context.Context, *connect_go.Request[v1alpha1.MappingsRequest]) (*connect_go.Response[v1alpha1.MappingsResponse], error)
	// Stacktraces retrieves mappings.
	Stacktraces(context.Context, *connect_go.Request[v1alpha1.StacktracesRequest]) (*connect_go.Response[v1alpha1.StacktracesResponse], error)
}

// NewMetastoreServiceClient constructs a client for the parca.metastore.v1alpha1.MetastoreService
// service. By default, it uses the Connect protocol with the binary Protobuf Codec, asks for
// gzipped responses, and sends uncompressed requests. To use the gRPC or gRPC-Web protocols, supply
// the connect.WithGRPC() or connect.WithGRPCWeb() options.
//
// The URL supplied here should be the base URL for the Connect or gRPC server (for example,
// http://api.acme.com or https://acme.com/grpc).
func NewMetastoreServiceClient(httpClient connect_go.HTTPClient, baseURL string, opts ...connect_go.ClientOption) MetastoreServiceClient {
	baseURL = strings.TrimRight(baseURL, "/")
	return &metastoreServiceClient{
		getOrCreateMappings: connect_go.NewClient[v1alpha1.GetOrCreateMappingsRequest, v1alpha1.GetOrCreateMappingsResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateMappings",
			opts...,
		),
		getOrCreateFunctions: connect_go.NewClient[v1alpha1.GetOrCreateFunctionsRequest, v1alpha1.GetOrCreateFunctionsResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateFunctions",
			opts...,
		),
		getOrCreateLocations: connect_go.NewClient[v1alpha1.GetOrCreateLocationsRequest, v1alpha1.GetOrCreateLocationsResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateLocations",
			opts...,
		),
		getOrCreateStacktraces: connect_go.NewClient[v1alpha1.GetOrCreateStacktracesRequest, v1alpha1.GetOrCreateStacktracesResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateStacktraces",
			opts...,
		),
		unsymbolizedLocations: connect_go.NewClient[v1alpha1.UnsymbolizedLocationsRequest, v1alpha1.UnsymbolizedLocationsResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/UnsymbolizedLocations",
			opts...,
		),
		createLocationLines: connect_go.NewClient[v1alpha1.CreateLocationLinesRequest, v1alpha1.CreateLocationLinesResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/CreateLocationLines",
			opts...,
		),
		locations: connect_go.NewClient[v1alpha1.LocationsRequest, v1alpha1.LocationsResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/Locations",
			opts...,
		),
		functions: connect_go.NewClient[v1alpha1.FunctionsRequest, v1alpha1.FunctionsResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/Functions",
			opts...,
		),
		mappings: connect_go.NewClient[v1alpha1.MappingsRequest, v1alpha1.MappingsResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/Mappings",
			opts...,
		),
		stacktraces: connect_go.NewClient[v1alpha1.StacktracesRequest, v1alpha1.StacktracesResponse](
			httpClient,
			baseURL+"/parca.metastore.v1alpha1.MetastoreService/Stacktraces",
			opts...,
		),
	}
}

// metastoreServiceClient implements MetastoreServiceClient.
type metastoreServiceClient struct {
	getOrCreateMappings    *connect_go.Client[v1alpha1.GetOrCreateMappingsRequest, v1alpha1.GetOrCreateMappingsResponse]
	getOrCreateFunctions   *connect_go.Client[v1alpha1.GetOrCreateFunctionsRequest, v1alpha1.GetOrCreateFunctionsResponse]
	getOrCreateLocations   *connect_go.Client[v1alpha1.GetOrCreateLocationsRequest, v1alpha1.GetOrCreateLocationsResponse]
	getOrCreateStacktraces *connect_go.Client[v1alpha1.GetOrCreateStacktracesRequest, v1alpha1.GetOrCreateStacktracesResponse]
	unsymbolizedLocations  *connect_go.Client[v1alpha1.UnsymbolizedLocationsRequest, v1alpha1.UnsymbolizedLocationsResponse]
	createLocationLines    *connect_go.Client[v1alpha1.CreateLocationLinesRequest, v1alpha1.CreateLocationLinesResponse]
	locations              *connect_go.Client[v1alpha1.LocationsRequest, v1alpha1.LocationsResponse]
	functions              *connect_go.Client[v1alpha1.FunctionsRequest, v1alpha1.FunctionsResponse]
	mappings               *connect_go.Client[v1alpha1.MappingsRequest, v1alpha1.MappingsResponse]
	stacktraces            *connect_go.Client[v1alpha1.StacktracesRequest, v1alpha1.StacktracesResponse]
}

// GetOrCreateMappings calls parca.metastore.v1alpha1.MetastoreService.GetOrCreateMappings.
func (c *metastoreServiceClient) GetOrCreateMappings(ctx context.Context, req *connect_go.Request[v1alpha1.GetOrCreateMappingsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateMappingsResponse], error) {
	return c.getOrCreateMappings.CallUnary(ctx, req)
}

// GetOrCreateFunctions calls parca.metastore.v1alpha1.MetastoreService.GetOrCreateFunctions.
func (c *metastoreServiceClient) GetOrCreateFunctions(ctx context.Context, req *connect_go.Request[v1alpha1.GetOrCreateFunctionsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateFunctionsResponse], error) {
	return c.getOrCreateFunctions.CallUnary(ctx, req)
}

// GetOrCreateLocations calls parca.metastore.v1alpha1.MetastoreService.GetOrCreateLocations.
func (c *metastoreServiceClient) GetOrCreateLocations(ctx context.Context, req *connect_go.Request[v1alpha1.GetOrCreateLocationsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateLocationsResponse], error) {
	return c.getOrCreateLocations.CallUnary(ctx, req)
}

// GetOrCreateStacktraces calls parca.metastore.v1alpha1.MetastoreService.GetOrCreateStacktraces.
func (c *metastoreServiceClient) GetOrCreateStacktraces(ctx context.Context, req *connect_go.Request[v1alpha1.GetOrCreateStacktracesRequest]) (*connect_go.Response[v1alpha1.GetOrCreateStacktracesResponse], error) {
	return c.getOrCreateStacktraces.CallUnary(ctx, req)
}

// UnsymbolizedLocations calls parca.metastore.v1alpha1.MetastoreService.UnsymbolizedLocations.
func (c *metastoreServiceClient) UnsymbolizedLocations(ctx context.Context, req *connect_go.Request[v1alpha1.UnsymbolizedLocationsRequest]) (*connect_go.Response[v1alpha1.UnsymbolizedLocationsResponse], error) {
	return c.unsymbolizedLocations.CallUnary(ctx, req)
}

// CreateLocationLines calls parca.metastore.v1alpha1.MetastoreService.CreateLocationLines.
func (c *metastoreServiceClient) CreateLocationLines(ctx context.Context, req *connect_go.Request[v1alpha1.CreateLocationLinesRequest]) (*connect_go.Response[v1alpha1.CreateLocationLinesResponse], error) {
	return c.createLocationLines.CallUnary(ctx, req)
}

// Locations calls parca.metastore.v1alpha1.MetastoreService.Locations.
func (c *metastoreServiceClient) Locations(ctx context.Context, req *connect_go.Request[v1alpha1.LocationsRequest]) (*connect_go.Response[v1alpha1.LocationsResponse], error) {
	return c.locations.CallUnary(ctx, req)
}

// Functions calls parca.metastore.v1alpha1.MetastoreService.Functions.
func (c *metastoreServiceClient) Functions(ctx context.Context, req *connect_go.Request[v1alpha1.FunctionsRequest]) (*connect_go.Response[v1alpha1.FunctionsResponse], error) {
	return c.functions.CallUnary(ctx, req)
}

// Mappings calls parca.metastore.v1alpha1.MetastoreService.Mappings.
func (c *metastoreServiceClient) Mappings(ctx context.Context, req *connect_go.Request[v1alpha1.MappingsRequest]) (*connect_go.Response[v1alpha1.MappingsResponse], error) {
	return c.mappings.CallUnary(ctx, req)
}

// Stacktraces calls parca.metastore.v1alpha1.MetastoreService.Stacktraces.
func (c *metastoreServiceClient) Stacktraces(ctx context.Context, req *connect_go.Request[v1alpha1.StacktracesRequest]) (*connect_go.Response[v1alpha1.StacktracesResponse], error) {
	return c.stacktraces.CallUnary(ctx, req)
}

// MetastoreServiceHandler is an implementation of the parca.metastore.v1alpha1.MetastoreService
// service.
type MetastoreServiceHandler interface {
	// GetOrCreateMappings checks if the mappings in the request are already
	// known and returns the known mapping (including its ID) if so. If a mapping
	// does not already exist, it is written to the backing metastore.
	GetOrCreateMappings(context.Context, *connect_go.Request[v1alpha1.GetOrCreateMappingsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateMappingsResponse], error)
	// GetOrCreateFunctions checks if the functions in the request are already
	// known and returns the known function (including its ID) if so. If a
	// function does not already exist, it is written to the backing metastore.
	GetOrCreateFunctions(context.Context, *connect_go.Request[v1alpha1.GetOrCreateFunctionsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateFunctionsResponse], error)
	// GetOrCreateLocations checks if the locations in the request are already
	// known and returns the known location (including its ID) if so. If a
	// location does not already exist, it is written to the backing metastore.
	GetOrCreateLocations(context.Context, *connect_go.Request[v1alpha1.GetOrCreateLocationsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateLocationsResponse], error)
	// GetOrCreateStacktraces checks if the stacktraces in the request are
	// already known and returns the known stacktrace (including its ID) if so.
	// If a stacktrace does not already exist, it is written to the backing
	// metastore.
	GetOrCreateStacktraces(context.Context, *connect_go.Request[v1alpha1.GetOrCreateStacktracesRequest]) (*connect_go.Response[v1alpha1.GetOrCreateStacktracesResponse], error)
	// UnsymbolizedLocations returns locations that can be symbolized but haven't
	// been asynchronously symbolized yet.
	UnsymbolizedLocations(context.Context, *connect_go.Request[v1alpha1.UnsymbolizedLocationsRequest]) (*connect_go.Response[v1alpha1.UnsymbolizedLocationsResponse], error)
	// CreateLocationLines creates the location lines contained in the provided
	// locations.
	CreateLocationLines(context.Context, *connect_go.Request[v1alpha1.CreateLocationLinesRequest]) (*connect_go.Response[v1alpha1.CreateLocationLinesResponse], error)
	// Locations retrieves locations.
	Locations(context.Context, *connect_go.Request[v1alpha1.LocationsRequest]) (*connect_go.Response[v1alpha1.LocationsResponse], error)
	// Functions retrieves functions.
	Functions(context.Context, *connect_go.Request[v1alpha1.FunctionsRequest]) (*connect_go.Response[v1alpha1.FunctionsResponse], error)
	// Mappings retrieves mappings.
	Mappings(context.Context, *connect_go.Request[v1alpha1.MappingsRequest]) (*connect_go.Response[v1alpha1.MappingsResponse], error)
	// Stacktraces retrieves mappings.
	Stacktraces(context.Context, *connect_go.Request[v1alpha1.StacktracesRequest]) (*connect_go.Response[v1alpha1.StacktracesResponse], error)
}

// NewMetastoreServiceHandler builds an HTTP handler from the service implementation. It returns the
// path on which to mount the handler and the handler itself.
//
// By default, handlers support the Connect, gRPC, and gRPC-Web protocols with the binary Protobuf
// and JSON codecs. They also support gzip compression.
func NewMetastoreServiceHandler(svc MetastoreServiceHandler, opts ...connect_go.HandlerOption) (string, http.Handler) {
	mux := http.NewServeMux()
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/GetOrCreateMappings", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateMappings",
		svc.GetOrCreateMappings,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/GetOrCreateFunctions", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateFunctions",
		svc.GetOrCreateFunctions,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/GetOrCreateLocations", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateLocations",
		svc.GetOrCreateLocations,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/GetOrCreateStacktraces", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/GetOrCreateStacktraces",
		svc.GetOrCreateStacktraces,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/UnsymbolizedLocations", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/UnsymbolizedLocations",
		svc.UnsymbolizedLocations,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/CreateLocationLines", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/CreateLocationLines",
		svc.CreateLocationLines,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/Locations", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/Locations",
		svc.Locations,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/Functions", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/Functions",
		svc.Functions,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/Mappings", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/Mappings",
		svc.Mappings,
		opts...,
	))
	mux.Handle("/parca.metastore.v1alpha1.MetastoreService/Stacktraces", connect_go.NewUnaryHandler(
		"/parca.metastore.v1alpha1.MetastoreService/Stacktraces",
		svc.Stacktraces,
		opts...,
	))
	return "/parca.metastore.v1alpha1.MetastoreService/", mux
}

// UnimplementedMetastoreServiceHandler returns CodeUnimplemented from all methods.
type UnimplementedMetastoreServiceHandler struct{}

func (UnimplementedMetastoreServiceHandler) GetOrCreateMappings(context.Context, *connect_go.Request[v1alpha1.GetOrCreateMappingsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateMappingsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.GetOrCreateMappings is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) GetOrCreateFunctions(context.Context, *connect_go.Request[v1alpha1.GetOrCreateFunctionsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateFunctionsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.GetOrCreateFunctions is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) GetOrCreateLocations(context.Context, *connect_go.Request[v1alpha1.GetOrCreateLocationsRequest]) (*connect_go.Response[v1alpha1.GetOrCreateLocationsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.GetOrCreateLocations is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) GetOrCreateStacktraces(context.Context, *connect_go.Request[v1alpha1.GetOrCreateStacktracesRequest]) (*connect_go.Response[v1alpha1.GetOrCreateStacktracesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.GetOrCreateStacktraces is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) UnsymbolizedLocations(context.Context, *connect_go.Request[v1alpha1.UnsymbolizedLocationsRequest]) (*connect_go.Response[v1alpha1.UnsymbolizedLocationsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.UnsymbolizedLocations is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) CreateLocationLines(context.Context, *connect_go.Request[v1alpha1.CreateLocationLinesRequest]) (*connect_go.Response[v1alpha1.CreateLocationLinesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.CreateLocationLines is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) Locations(context.Context, *connect_go.Request[v1alpha1.LocationsRequest]) (*connect_go.Response[v1alpha1.LocationsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.Locations is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) Functions(context.Context, *connect_go.Request[v1alpha1.FunctionsRequest]) (*connect_go.Response[v1alpha1.FunctionsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.Functions is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) Mappings(context.Context, *connect_go.Request[v1alpha1.MappingsRequest]) (*connect_go.Response[v1alpha1.MappingsResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.Mappings is not implemented"))
}

func (UnimplementedMetastoreServiceHandler) Stacktraces(context.Context, *connect_go.Request[v1alpha1.StacktracesRequest]) (*connect_go.Response[v1alpha1.StacktracesResponse], error) {
	return nil, connect_go.NewError(connect_go.CodeUnimplemented, errors.New("parca.metastore.v1alpha1.MetastoreService.Stacktraces is not implemented"))
}
